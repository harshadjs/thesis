* Decoupling Identification from Content
** Goals
- [1] Achieve the Ability to Assign Any ID to Any Content
- [2] Achieve Authenticity
- [3] Achieve Intergrity
- [4] Achieve Confidentiality
- [5] Achieve In-Network Caching Like Today

** Option 1
Server adds SHA1SUM(ID+DATA) into the content header
- Achieves 1, 3, 5
- Inexpensive
- (-) Someone else could generate some other content with same ID and
  there will be no way to verify which one is "genuine"

** Option 2
Server adds PRIV_server(SHA1SUM(ID+DATA)) into the content header
- Achieves 1, 2, 3, 5
- A little more expensive
- (?) Every cache that decides to cache the content must somehow get
  the server public key in order to cache only the correct
  content. Key distribution becomes an important problem.

** Option 3
Server adds PUB_client(PRIV_server(SHA1SUM(ID+DATA))) into the content
header
- Achieves 1, 2, 3, 4, 5
- Very expensive
- (?) Is this really needed? If the client wants confidentiality that
  implies that it does not want content to be cached in the network.
  - (_Against_) Find out scenarios where multiple clients share a key
    in order to achieve something
  - Intuition is that this might not be the widely requested mode of
    operation

** Choosing the ID: Avoiding Duplicates?
- Is it really important?

** Content Key Distribution Discussion
It is clear that having only the option 1 is not sufficient since it
is easy to disrupt / confuse such a system. Caches need server public
keys!
- XIA uses SIDs to fetch the content. i.e. the client downloads
  the content from the producer the very first time. How about
  publishing the public key then? over the SID?
- Impact on API:
- Signing the keys: How does the key consumer believe that the key
  really belongs to the one who published it
** CID Trust Model
- Read:
  http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.362.7257&rep=rep1&type=pdf
  http://storage.jak-stik.ac.id/rsasecurity/PKIPaper.pdf
  Naming paper for the idea for naming
- Consumer must have the ability to
  - Verify content integrity
  - Verify content authenticity
- Keys in XIA
  - Every key is identified by KID
    - the SHA1 checksum of the key
    - the SHA1 checksum of the encrypted (with parent key) version of
      the key
  - Key can be cached anywhere in the network like content.
  - Every key which is verified by some other key has the address of
    form KID_parent->KID_child.
  - Content verified by a particular key has the address .->KID->CID.
  - Network now knows how a particular content object was authorized.
  - Keys are like RIDs: they are content and but have different
    routing semantics.
    - How is key routing different than content routing?
  - Content object verified by a particular KID contains a digital
    signature created by the content and that particular key
** What about late binding / rebinding of ID--Content?

** Content Invalidation
Key Revocation

** Efficiency
* Defining Keys in XIA
